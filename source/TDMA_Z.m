 function T = TDMA_Z(A,B,C,Ap,Bp,Cp,b,Tn,BCtypes,Tbc)% TDMA algorithm for the 1-D vertical CVPM model, sweeping from top to bottom.% ______________________________________________%	Copyright (C) 2018, Gary Clow%   This program is free software: you can redistribute it and/or modify%   it under the terms of the GNU General Public License as published by%   the Free Software Foundation, version 3 of the License.%   This program is distributed in the hope that it will be useful,%   but WITHOUT ANY WARRANTY; without even the implied warranty of%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%   GNU General Public License v3.0 for more details.%   You should have received a copy of the GNU General Public License%   along with this program.  If not, see <http://www.gnu.org/licenses/>.%	Developer can be contacted by,%	email at:%		gary.clow@colorado.edu%	paper mail at:%		Institute of Arctic and Alpine Research%		University of Colorado%		Campus Box 450%		Boulder, CO 80309-0450 USA% ______________________________________________% Currently allowed boundary conditions:%   upperBC_type:	'T'     prescribed temperature%   lowerBC_type:	'T'     prescribed temperature%                   'q'     prescribed heat flux% Notation:%   A,B,C,Ap,Bp,Cp,b    DE coefficients                 (M)%   T                   temperature                     (M+1)%   Tn                  temperature, last time step     (M+1)%   Tbc                 Ts,Tb                           (2)% Notes:%   (1) Tb is not used if lowerBC_type = 'q'.%   (2) This routine does not find the temperature on the lower boundary%       if lowerBC_type = 'q'.% ______________________________________________ M = length(Tn) - 1;% pre-allocate arrays F = zeros(M,1); P = zeros(size(Tn)); Q = zeros(size(Tn)); T = zeros(size(Tn));% unpack BCs lowerBC_type = BCtypes{2}; Ts = Tbc(1); Tb = Tbc(2);% coefficient F F(2:M) = Ap(2:M) .* Tn(1:M-1) + Bp(2:M) .* Tn(2:M) ...        + Cp(2:M) .* Tn(3:M+1) + b(2:M); switch lowerBC_type case 'q'   F(M) = Ap(M)*Tn(M-1) + Bp(M)*Tn(M) + b(M); end% recursion coefficients P,Q switch lowerBC_type case 'T'   P(M+1) = 0;   Q(M+1) = Tb; case 'q'   P(M+1) = 0;   Q(M+1) = 0; end for k=M:-1:2   fac  =  B(k) - C(k)*P(k+1);   P(k) =  A(k) / fac;   Q(k) = (F(k) + C(k)*Q(k+1)) / fac; end% temperature on upper boundary T(1) = Ts;% temperature at internal grid points for k=2:M   T(k) = P(k)*T(k-1) + Q(k); end% temperature at lower boundary switch lowerBC_type case 'T'   T(M+1) = Tb; end