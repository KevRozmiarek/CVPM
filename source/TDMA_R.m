 function T = TDMA_R(D,B,E,Dp,Bp,Ep,b,Tn,BCtypes,Tbc)% TDMA algorithm for the 1-D radial CVPM model, sweeping from left to right.% Currently allowed boundary conditions:%   innerBC_type:   'T'     prescribed temperature%                   'none'  no boundary condition%   outerBC_type:	'T'     prescribed temperature%                   'q'     prescribed heat flux% Notation:%   A,B,C,Ap,Bp,Cp,b    DE coefficients                 (N)%   T                   temperature                     (N+1)%   Tn                  temperature, last time step     (N+1)%   Tbc                 Ta,To                           (2)% Notes:%   (1) Ta is not used if innerBC_type = 'none'.%   (2) To is not used if outerBC_type = 'q'.%   (3) This routine does not find the temperature on the outer boundary%       if outerBC_type = 'q'.% ______________________________________________% Written by:%   Gary Clow%   Institute of Arctic and Alpine Research%   University of Colorado%   Boulder, Colorado USA%   Email: gary.clow@colorado.edu% ______________________________________________ N = length(Tn) - 1;% pre-allocate arrays F = zeros(N,1); P = zeros(size(Tn)); Q = zeros(size(Tn)); T = zeros(size(Tn));% unpack BCs innerBC_type = BCtypes{1}; outerBC_type = BCtypes{2}; Ta = Tbc(1); To = Tbc(2);% coefficient F F(2:N) = Dp(2:N) .* Tn(1:N-1) + Bp(2:N) .* Tn(2:N) ...        + Ep(2:N) .* Tn(3:N+1) + b(2:N); switch innerBC_type case 'none'   F(1) = Bp(1)*Tn(1) + Ep(1)*Tn(2) + b(1); end switch outerBC_type case 'q'   F(N) = Dp(N)*Tn(N-1) + Bp(N)*Tn(N) + b(N); end% recursion coefficients P,Q switch outerBC_type case 'T'   P(N+1) = 0;   Q(N+1) = To; case 'q'   P(N+1) = 0;   Q(N+1) = 0; end for j=N:-1:2   fac  =  B(j) - E(j)*P(j+1);   P(j) =  D(j) / fac;   Q(j) = (E(j)*Q(j+1) + F(j)) / fac; end% temperature on inner boundary switch innerBC_type case 'T'   T(1) = Ta;                       % this grid point is at the boundary case 'none'   fac  =  B(1) - E(1)*P(2);   P(1) =  0;   Q(1) = (F(1) + E(1)*Q(2)) / fac;   T(1) =  Q(1);                    % this grid point is at the very center (r=0) end% temperature at internal grid points for j=2:N   T(j) = P(j)*T(j-1) + Q(j); end% temperature at the outer boundary switch outerBC_type case 'T'   T(N+1) = To; end