 function T = TDMA_R(D,B,E,Dp,Bp,Ep,b,Tn,BCtypes,Tbc)% TDMA algorithm for the 1-D radial CVPM model, sweeping from left to right.% ______________________________________________%	Copyright (C) 2018, Gary Clow%   This program is free software: you can redistribute it and/or modify%   it under the terms of the GNU General Public License as published by%   the Free Software Foundation, version 3 of the License.%   This program is distributed in the hope that it will be useful,%   but WITHOUT ANY WARRANTY; without even the implied warranty of%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%   GNU General Public License v3.0 for more details.%   You should have received a copy of the GNU General Public License%   along with this program.  If not, see <http://www.gnu.org/licenses/>.%	Developer can be contacted by,%	email at:%		gary.clow@colorado.edu%	paper mail at:%		Institute of Arctic and Alpine Research%		University of Colorado%		Campus Box 450%		Boulder, CO 80309-0450 USA% ______________________________________________% Currently allowed boundary conditions:%   innerBC_type:   'T'     prescribed temperature%                   'none'  no boundary condition%   outerBC_type:	'T'     prescribed temperature%                   'q'     prescribed heat flux% Notation:%   A,B,C,Ap,Bp,Cp,b    DE coefficients                 (N)%   T                   temperature                     (N+1)%   Tn                  temperature, last time step     (N+1)%   Tbc                 Ta,To                           (2)% Notes:%   (1) Ta is not used if innerBC_type = 'none'.%   (2) To is not used if outerBC_type = 'q'.%   (3) This routine does not find the temperature on the outer boundary%       if outerBC_type = 'q'.% ______________________________________________ N = length(Tn) - 1;% pre-allocate arrays F = zeros(N,1); P = zeros(size(Tn)); Q = zeros(size(Tn)); T = zeros(size(Tn));% unpack BCs innerBC_type = BCtypes{1}; outerBC_type = BCtypes{2}; Ta = Tbc(1); To = Tbc(2);% coefficient F F(2:N) = Dp(2:N) .* Tn(1:N-1) + Bp(2:N) .* Tn(2:N) ...        + Ep(2:N) .* Tn(3:N+1) + b(2:N); switch innerBC_type case 'none'   F(1) = Bp(1)*Tn(1) + Ep(1)*Tn(2) + b(1); end switch outerBC_type case 'q'   F(N) = Dp(N)*Tn(N-1) + Bp(N)*Tn(N) + b(N); end% recursion coefficients P,Q switch outerBC_type case 'T'   P(N+1) = 0;   Q(N+1) = To; case 'q'   P(N+1) = 0;   Q(N+1) = 0; end for j=N:-1:2   fac  =  B(j) - E(j)*P(j+1);   P(j) =  D(j) / fac;   Q(j) = (E(j)*Q(j+1) + F(j)) / fac; end% temperature on inner boundary switch innerBC_type case 'T'   T(1) = Ta;                       % this grid point is at the boundary case 'none'   fac  =  B(1) - E(1)*P(2);   P(1) =  0;   Q(1) = (F(1) + E(1)*Q(2)) / fac;   T(1) =  Q(1);                    % this grid point is at the very center (r=0) end% temperature at internal grid points for j=2:N   T(j) = P(j)*T(j-1) + Q(j); end% temperature at the outer boundary switch outerBC_type case 'T'   T(N+1) = To; end